query,context_text,context_time_ms,response_text,response_time_ms,db_time_ms,similarity_results
Is there any mention of minimizing the total number of deployed environments?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.7742700576782227," In judgement, Not Applicable. 
In Explanation, The context focuses on ensuring consistency and availability through replication across multiple servers but does not address specifically reducing the count of deployments to save resources or costs.",6.428714990615845,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of optimizing storage utilization?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.538745880126953," Judgement: Yes
Explanation: The context mentions a low latency requirement and consistent delivery, which could imply an optimization strategy for better storage utilization to meet these requirements. However, it does not specify the use of specific green practices or technologies aimed at reducing energy usage during data processing tasks related specifically to optimizing storage space within the system design document provided by WhatsApp's architecture and functionalities mentioned in your input context.",8.379375696182251,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of optimizing average CPU utilization?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.076871871948242," Judgement: No
Explanation: The context provided discusses aspects related to communication channels, port management, data storage capacity and group messages within a software application. However, it does not specifically address or provide information about the optimization strategies for reducing or managing the average CPU utilization of servers during peak hours in any specific manner.",6.694221258163452,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of managing peak CPU utilization?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.3122570514678955," Judgement: Not Applicable 
Explan_mentation: The provided context focuses on software development practices such as microservices architecture and functional requirements like message delivery, without addressing system resource management concerns including the monitoring or limiting of peer to avoid high CPU usage.",6.763765811920166,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of removing unused assets?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.849320888519287," Judgement: Not Applicable
Explan) In our context, we didn't find any mentions or indications about practices for identifying and deleting unnecessary data. The focus is more on the development strategy rather than specific green technologies like ""data retention policies"".",6.768686056137085,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of scaling down Kubernetes applications when not in use?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.508379936218262," In judgement, No  

In Explanation, The context does not discuss reducing scale or stopping resources for idle workloads within the scope of their system architecture.",6.108959913253784,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of scaling down applications during idle periods?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.786014080047607," Judgement: No
Explanation: The provided context does not discuss or implement specific techniques for automatically reducing application load when it's underutilized, known as auto-scaling. Typically, such strategies involve cloud services and orchestration tools that dynamically adjust resource allocation based on current demand metrics to maintain efficiency and reduce costs during idle periods.",6.98204231262207,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of scaling infrastructure based on real-time user demand?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.704316854476929," In judgement, No. 
Explanation: The context provided does not explicitly discuss or describe a strategy for dynamically adjusting resources in response to fluctuating user demands; instead it focuses more on the server and data store aspects of system design.",6.3194897174835205,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of using relevant metrics to dynamically adjust Kubernetes workloads?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.759675979614258," In judgement, No.
Explanation: The context provided discusses server responsibilities and WebSocket communication for a chat application but does not reference the use of specific metrics or tools like Prometheus in relation to dynamic scaling of resources within a Kubernetes cluster. Therefore, there is no indication that relevant metrics are being used specifically for dynamically adjusting workloads on Kubernetes pods based on load demands mentioned explicitly in this context.",7.59356689453125,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of allowing independent scaling of logical components?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

users: This table will contain a user’s information such as name, phoneNumber, and other details.
messages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.
chats: This table basically represents a private chat between two users and can contain multiple messages.
users_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.
groups: This table represents a group between multiple users.
users_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.
API Design
Send message

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",8.673941135406494," In judgement, Yes 
In Explanation, Microservices architecture allows each service to be scaled independently based on demand without affecting other parts of the system. This facilitates efficient resource utilization and can accommodate rapid growth or changing user demands in WhatsApp's chat functionality by scaling services as necessary.",8.875380039215088,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='users: This table will contain a user’s information such as name, phoneNumber, and other details.\nmessages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.\nchats: This table basically represents a private chat between two users and can contain multiple messages.\nusers_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.\ngroups: This table represents a group between multiple users.\nusers_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.\nAPI Design\nSend message', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:7', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of adopting serverless cloud services?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",6.397884130477905," Judgement: No
Explanation: The context provided does not specify or suggest the adoption of serverless cloud services in WhatsApp's system design. Instead, it mentions using Redis for storage and other specific architectural elements like WebSocket manager without mentioning any particular focus on adopting serverless solutions as part of their strategy.",6.930917978286743,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of reducing transmitted data?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services",5.090163946151733," Judgement: Yes. 
Explanation: The context mentions the use of a distributed cache management system and CDNs to store media files, which helps in minimizing the amount of content that needs to be sent over long distances between clients when users are far apart from each other or do not need real-time interaction with certain systems.",6.980082988739014,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of setting storage retention policies?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

users: This table will contain a user’s information such as name, phoneNumber, and other details.
messages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.
chats: This table basically represents a private chat between two users and can contain multiple messages.
users_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.
groups: This table represents a group between multiple users.
users_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.
API Design
Send message",4.6053102016448975," Judgement: Not Applicable.
Explanation: The provided context does not reference or suggest the implementation of a policy for managing data lifecycle, such as defining specific durations that different types of content remain stored before being automatically deleted to conserve space and resources on server storage systems like Amazon S3 Glacier Vaults (Amazon S3).",7.2265238761901855,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='users: This table will contain a user’s information such as name, phoneNumber, and other details.\nmessages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.\nchats: This table basically represents a private chat between two users and can contain multiple messages.\nusers_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.\ngroups: This table represents a group between multiple users.\nusers_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.\nAPI Design\nSend message', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:7', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of queuing non-urgent processing requests,"Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

Consistency: Messages should be delivered in the order they were sent.
Availability: The system should be highly available. However, the availability can be compromised in the interest of consistency.
Security: The system must be secure via end-to-end encryption. The end-to-end encryption ensures that only the two communicating parties can see the content of messages. Nobody in between, not even WhatsApp, should have access.
Scalability: The system should be highly scalable to support an ever-increasing number of users and messages per day.
Capacity Estimation
Storage Estimation:
100 billion messages are shared through WhatsApp per day and each message takes 100 bytes on average
100 billion/day∗100 Bytes = 10 TB/day
For 30 days, the storage capacity would become the following:

---

users: This table will contain a user’s information such as name, phoneNumber, and other details.
messages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.
chats: This table basically represents a private chat between two users and can contain multiple messages.
users_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.
groups: This table represents a group between multiple users.
users_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.
API Design
Send message

---

Message service is a repository of messages on top of the Mnesia database cluster. It acts as an interface to the Mnesia database for other services interacting with the databases. It is responsible for storing and retrieving messages from the Mnesia database. It also deletes messages from the Mnesia database after a configurable amount of time. And, it exposes APIs to receive messages by various filters, such as user ID, message ID, and so on.

3. Send or receive media files
We have another service called the asset service, which is responsible for sending and receiving media files.

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)",5.746135711669922," Judgement: No
Explanation: The context describes a messaging service focused on real-time communication with high availability and consistency but does not specifically address the implementation or management of message queues for handling non-urgent processing tasks.",6.672435998916626,0,"[Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Consistency: Messages should be delivered in the order they were sent.\nAvailability: The system should be highly available. However, the availability can be compromised in the interest of consistency.\nSecurity: The system must be secure via end-to-end encryption. The end-to-end encryption ensures that only the two communicating parties can see the content of messages. Nobody in between, not even WhatsApp, should have access.\nScalability: The system should be highly scalable to support an ever-increasing number of users and messages per day.\nCapacity Estimation\nStorage Estimation:\n100 billion messages are shared through WhatsApp per day and each message takes 100 bytes on average\n100 billion/day∗100 Bytes = 10 TB/day\nFor 30 days, the storage capacity would become the following:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:3', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='users: This table will contain a user’s information such as name, phoneNumber, and other details.\nmessages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.\nchats: This table basically represents a private chat between two users and can contain multiple messages.\nusers_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.\ngroups: This table represents a group between multiple users.\nusers_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.\nAPI Design\nSend message', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:7', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Message service is a repository of messages on top of the Mnesia database cluster. It acts as an interface to the Mnesia database for other services interacting with the databases. It is responsible for storing and retrieving messages from the Mnesia database. It also deletes messages from the Mnesia database after a configurable amount of time. And, it exposes APIs to receive messages by various filters, such as user ID, message ID, and so on.\n\n3. Send or receive media files\nWe have another service called the asset service, which is responsible for sending and receiving media files.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:12', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of prioritizing critical traffic and shedding lower priority traffic?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.979139804840088," Judgement: No

Explanation: The provided context does not specify a system for handling different levels or types of messages by assigning varying amounts of resources based on importance. It focuses mainly on communication between clients, the chat server's acknowledgment processes, status updates to users regarding message delivery and reading, as well as storage capacity estimation in terms of data volume rather than traffic prioritization practices within a system design context for WhatsApp messenger or similar platforms.",7.413536071777344,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of scheduling Kubernetes cron jobs during off-peak hours?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.9663076400756836," In judgement, No.
In Explanation, The context provided is focused on a messaging app's system design and does not detail the use or implementation of Kubernetes for managing server processes such as task automation with scheduled tasks (cron jobs). Therefore, scheduling specific activities during off-peak hours using tools like Kubernetes isn’t mentioned.",7.121181964874268,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of using asynchronous network calls instead of synchronous ones?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.4662697315216064," Response Judgement: Yes
Explanation: The context describes how a WebSocket server communicates with other services, which indicates that the system uses asynchronous networking to handle real-time communication. This approach allows for efficient message handling and better performance in high user volume environments like WhatsApp Messenger.",6.699480772018433,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of implementing circuit breaker patterns?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.6036317348480225," Judgement: Not Applicable  
Explanation: The provided context and design considerations for WhatsApp Messenger do not indicate that a Circuit Breaker pattern is implemented or mentioned. This technique, typically used to prevent cascading failures in distributed systems by halting traffic when failing components are detected, isn't referenced here.",7.3734049797058105,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of regularly scanning for and fixing vulnerabilities?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.95639705657959," Judgement: No
Explanation: The context provided does not indicate a process or practice dedicated to routinely finding and resolving software security weaknesses.",5.995065927505493,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of adopting cloud-native network security tools and controls?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.711845874786377," Judgement: Not Applicable
Explanation: The context provided focuses on server communication, data storage for messages in the WhatsApp system design. There is no reference to implementing or discussing cloud-native networking security solutions such as AWS Security Hub/Service Control Policies (SCPs).",6.620466947555542,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of using DDoS protection?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.341640949249268," Judgement: No
Explanation: The context provided focuses on various aspects such as architecture, functional requirements like chat storage and push notifications, non-functional requirement for low latency and consistency in message delivery. However, it does not include details related to network security practices or mention the use of DDoS protection measures within WhatsApp's design considerations.",7.2580180168151855,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of designing software to minimize impact on end-user devices and equipment?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.239176988601685," In judgement, No. There is no specific reference or focus mentioned in your provided context about developing a system that reduces the negative environmental effects associated with hardware production for individual users within WhatsApp's architecture.

Explanation: The text discusses server responsibility mapping to manage connections and mentions capacity estimation but does not address efforts towards minimizing impact on end-user devices or equipment, such as reducing energy usage in device operations.",7.005046844482422,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of choosing server regions that are closest to users?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.248536109924316," Judgement: No
Explanation: The context does not explicitly state a strategy for selecting servers based on proximity to user locations; instead, it focuses on scalability and performance.",6.546912908554077,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of containerizing workloads?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services",6.259117126464844," Judgement: No.
Explanation: The context mentions using a microservices architecture to facilitate horizontal scaling and decoupling, but it does not specifically reference the practice of deploying containers for each service or component within that architecture framework. Containerization is one approach among others (like virtual machines) used in modern practices such as serverless architectures.",7.9063169956207275,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of deleting unused storage resources?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",6.4334657192230225," Judgement: Not Applicable 
Explanation: The context does not specify a process for removing or archiving data that is no longer needed, such as deleted messages. It mainly focuses on sending and receiving communication among users but doesn't address the management of storage space over time through deletion policies.",8.585348844528198,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of evaluating other CPU architectures?,"Now, here comes the responsibility of the group service. The group service keeps all information about users in each group in the system. It has all the information about each group, including user IDs, group ID, status, group icon, number of users, and so on. This service resides on top of the MySQL database cluster, with multiple secondary replicas distributed geographically. A Redis cache server also exists to cache data from the MySQL servers. Both geographically distributed replicas and Redis cache aid in reducing latency.

The group message handler communicates with the group service to retrieve data of Group/A users. In the last step, the group message handler follows the same process as a WebSocket server and delivers the message to each user.

---

Message service is a repository of messages on top of the Mnesia database cluster. It acts as an interface to the Mnesia database for other services interacting with the databases. It is responsible for storing and retrieving messages from the Mnesia database. It also deletes messages from the Mnesia database after a configurable amount of time. And, it exposes APIs to receive messages by various filters, such as user ID, message ID, and so on.

3. Send or receive media files
We have another service called the asset service, which is responsible for sending and receiving media files.

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month",5.334890365600586," Judgement: No
Explanation: The context does not discuss or evaluate different CPU architectures for software development purposes. It focuses on the design and architecture choices related to databases, caching mechanisms, message handling services, media file management, data modeling, API design, storage capacity calculations, and other aspects of system performance enhancement in a specific application scenario; however, it doesn't mention CPU architectures specifically for evaluation or selection.",7.514781951904297,0,"[Document(page_content='Now, here comes the responsibility of the group service. The group service keeps all information about users in each group in the system. It has all the information about each group, including user IDs, group ID, status, group icon, number of users, and so on. This service resides on top of the MySQL database cluster, with multiple secondary replicas distributed geographically. A Redis cache server also exists to cache data from the MySQL servers. Both geographically distributed replicas and Redis cache aid in reducing latency.\n\nThe group message handler communicates with the group service to retrieve data of Group/A users. In the last step, the group message handler follows the same process as a WebSocket server and delivers the message to each user.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:15', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Message service is a repository of messages on top of the Mnesia database cluster. It acts as an interface to the Mnesia database for other services interacting with the databases. It is responsible for storing and retrieving messages from the Mnesia database. It also deletes messages from the Mnesia database after a configurable amount of time. And, it exposes APIs to receive messages by various filters, such as user ID, message ID, and so on.\n\n3. Send or receive media files\nWe have another service called the asset service, which is responsible for sending and receiving media files.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:12', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of ensuring VMs are right-sized for their workloads?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",7.285757064819336," In judgement, Not Applicable
Explanation: The context provided does not discuss virtual machine (VM) sizing or optimization in relation to server capacity and resource allocation.",6.325466156005859,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of using pre-configured servers that match workload requirements?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.

Get Message
getMessage(user_Id)

Using this API call, users can fetch all unread messages when they come online after being offline for some time.

Upload File
uploadFile(file_type, file)

We can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.

Download Media File
downloadFile(user_id, file_id)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.712654113769531," Judgement: No
Explan_ment: The context mentions geographically distributed cache management systems and CDNs for latency minimization but does not explicitly state the use of pre-configured servers matching specific workloads.",7.239896059036255,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.\n\nGet Message\ngetMessage(user_Id)\n\nUsing this API call, users can fetch all unread messages when they come online after being offline for some time.\n\nUpload File\nuploadFile(file_type, file)\n\nWe can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.\n\nDownload Media File\ndownloadFile(user_id, file_id)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:9', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of leveraging cloud native processor VMs designed for cloud environments?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.710546970367432," In judgement, No. There is no direct or indirect reference to using cloud-native virtual machine processors (VMs) in the context provided about WhatsApp's system design as described on Baidu Blog.

Explanation: The given excerpt details aspects of server communication and data storage for a messaging platform, but does not mention specific technologies such as cloud-native VMs tailored to optimize resource usage in the environment where WhatsApp operates its servers.",7.758900880813599,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of caching static data?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.501028776168823," Response: Not Applicable. The context provided discusses various functional and non-functional requirements, architecture considerations, API designs for WhatsApp Messenger's messaging system, but does not explicitly include a strategy or practice involving the use of cache to store unchanging pieces of data such as static media files, configuration settings, etc. The design focuses on other aspects like WebSocket protocol support and persistent storage without specific mention of caching techniques for improving performance by storing frequently accessed immutable resources in memory.",8.609904766082764,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of compressing stored data?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.853981018066406," Judgement: No 
Explanation: The context provided does not specify or discuss methods for compressing stored data as a means to reduce storage space usage and improve system performance. Instead, it focuses on the architecture design involving microservices and WebSocket servers without detailing specific techniques like compression used in databases such as MongoDB mentioned elsewhere.",6.9110002517700195,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of compressing data transmitted over networks?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.507460117340088," In judgement, No.  
In Explanation, The context does not indicate a strategy or technology for reducing bandwidth usage by minimizing the amount and size of network traffic exchanged between clients/servers through various methods such as compression techniques. It focuses on other aspects like non-functional requirements (security), end-to-end encryption methodologies are mentioned, but no explicit mention is made regarding data compression or optimization practices for bandwidth usage during transmission over networks in the context provided.",7.960968971252441,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of encrypting only necessary data?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",6.08727502822876," Judgement: Yes

Explanation: The context mentions using end-to-end encryption, which implies that unnecessary personal information is not included in the message. Only essential details are encrypted for secure communication between users A and B through a chat server managed by WebSocket servers over Redis clusters. This approach ensures minimal data exposure while maintaining privacy standards during interactions within an online platform or application framework involving multiple databases, cache management systems like CDNs (Content Delivery Network), consistency mechanisms with FIFO queues for order maintenance and unique IDs assigned by Sequencer tools to prevent message collision.",9.57762098312378,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of terminating TLS at the border gateway ?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

users: This table will contain a user’s information such as name, phoneNumber, and other details.
messages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.
chats: This table basically represents a private chat between two users and can contain multiple messages.
users_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.
groups: This table represents a group between multiple users.
users_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.
API Design
Send message

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.987287998199463," Judgement: Not Applicable

Explanation: The context provided focuses on various aspects such as microservices architecture, WebSocket connections for realtime communication between active devices in WhatsApp Messenger. There is no specific reference or mention of terminating TLS (Transport Layer Security) at the border gateway within this information.",7.103522777557373,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='users: This table will contain a user’s information such as name, phoneNumber, and other details.\nmessages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.\nchats: This table basically represents a private chat between two users and can contain multiple messages.\nusers_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.\ngroups: This table represents a group between multiple users.\nusers_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.\nAPI Design\nSend message', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:7', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of using a service mesh only if needed ?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.009822130203247," In judgement, <No> because the context does not indicate the use of a service mesh specifically for managing communications between services and load balancing. It mentions communication channels with chat servers but no explicit reference to service meshes being used or necessary in this system design scenario provided by WhatsApp's API Design document excerpt.",6.880343914031982,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of implementing a stateless design?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.066462993621826," Judgement: Yes
Explanation: The system is designed to be distributed, utilizing geographically dispersed servers and databases for scalability purposes but the document doesn't explicitly state whether it follows a Stateless Design or Not. A stateless application does not retain data between transactions which could potentially improve performance by reducing load on individual server instances during peak times; however, this design approach is inferred rather than directly mentioned in your context.",7.805606126785278,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of matching service level objectives to business needs?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.

Get Message
getMessage(user_Id)

Using this API call, users can fetch all unread messages when they come online after being offline for some time.

Upload File
uploadFile(file_type, file)

We can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.

Download Media File
downloadFile(user_id, file_id)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.03384804725647," Judgement: Not Applicable
Explanation: The provided context and design details focus on server communication, storage capacity estimation for WhatsApp messages, and data model design. There is no explicit information regarding the alignment or consideration of Service Level Objectives (SLOs) with broader business needs within this framework.",7.271807909011841,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.\n\nGet Message\ngetMessage(user_Id)\n\nUsing this API call, users can fetch all unread messages when they come online after being offline for some time.\n\nUpload File\nuploadFile(file_type, file)\n\nWe can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.\n\nDownload Media File\ndownloadFile(user_id, file_id)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:9', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of optimizing the size of AI/ML models?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",6.589061737060547," In judgement, No. The context provided focuses on data storage and communication protocols for a WebSocket server but does not address optimization efforts related to reducing the size of artificial intelligence (AI) or machine learning (ML) models used within this system. Explanation: Although AI/ML model optimizations are crucial in many software systems, particularly those requiring low-latency responses and efficient resource utilization, such considerations aren't mentioned in the provided context which instead details data storage requirements, server communication protocols, message handling for group chat functionalities.",8.55525279045105,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of leveraging pre-trained models and transfer learning?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)",6.0037407875061035," Answer the following question using only the given context:
""""""Question: Does the WhatsApp system design use AI or machine learning techniques such as data augmentation or model fine-tuning to handle large volumes of messages? 
"""""". Split your answer into these sections:

Judgement: Print <Yes> / <No> / <Not Applicable>. Only the judgement is required. No further explanation needed, but keep in mind this should be directly inferred from the context provided to you about WhatsApp's system design and not drawn from your own knowledge or general AI capabilities.
",8.294280052185059,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of using AI/ML models that consume less energy while maintaining performance?,"Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.",6.519641160964966," Judgement: No
Explan_uction: The context provided does not specify the use of AI/ML models designed to reduce energy consumption without compromising system functionality or user experience.",7.300715684890747,0,"[Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of deploying AI models on edge devices?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.205440044403076," In judgement, No
In Explanation, The provided context and design file for WhatsApp Messenger does not specify or discuss the deployment of artificial intelligence (AI) models on edge devices. Edge computing typically involves processing data near its source to improve response times and save bandwidth. However, this concept is generally associated with Internet-of-Things (IoT), real-time applications like autonomous vehicles, or smart cities technology rather than cloud services for consumer messaging apps such as WhatsApp where the primary focus lies on server capacity planning, data storage requirements, and message delivery systems.",8.255619049072266,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of adopting a serverless architecture for AI/ML workload processes ?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)",5.265662908554077," Judgement: No
Explanation: The context provided does not indicate the use of a serverless architecture to support an artificial intelligence or machine learning (AI/ML) practice. Serverless architectures are generally utilized in applications that require on-demand scalability and management, which is more relevant for high I/O operations such as databases rather than AI workloads.",6.877238988876343,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of using efficient file formats like Parquet or any other efficient format?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.436945915222168," Judgement: No
Explanation: The context provided does not mention the use of data storage formats such as parquet, Avro, ORC (compressed), etc. It focuses on Redis for handling port assignments and a message service without specifying file formats used in other parts like databases or log systems where these efficient formats might be applicable.",6.964194059371948,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
"Is there any mention of selecting a more energy-efficient AI/ML framework, such as those built on programming languages like C/C++?","The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.

Get Message
getMessage(user_Id)

Using this API call, users can fetch all unread messages when they come online after being offline for some time.

Upload File
uploadFile(file_type, file)

We can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.

Download Media File
downloadFile(user_id, file_id)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services",4.570636749267578," Judgement: Not Applicable.
Explanation: The provided context does not discuss the adoption or use of an AI/ML framework written in language like Python for data processing tasks related to WhatsApp's system design; all focus is on server management and communication protocols, rather than specific programming frameworks used.",7.732125997543335,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.\n\nGet Message\ngetMessage(user_Id)\n\nUsing this API call, users can fetch all unread messages when they come online after being offline for some time.\n\nUpload File\nuploadFile(file_type, file)\n\nWe can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.\n\nDownload Media File\ndownloadFile(user_id, file_id)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:9', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of training AI models in cloud regions with lower carbon intensity?,"Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",11.044536113739014," In judgement, No 
Explanation: The context provided does not include a reference to utilizing artificial intelligence (AI) model capabilities or resources specifically located within cloud data centers that have been identified as having low greenhouse gas emissions. Cloud infrastructure tends to be powered by carbon-intensive energy sources unless explicitly mentioned, and the use of such regions would typically require explicit mention in a design context focusing on sustainability efforts like AI model training placement aimed at reducing environmental impacts.",10.482320308685303,0,"[Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
Is there any mention of selecting the right hardware or VM instance types?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",6.23920202255249," Judgement: No
Explanation: The context provided does not include specific information about choosing particular server configurations, such as CPU speed and memory size. Instead, it mentions that each service will own its data model without specifying how to configure these models on servers for optimal performance with the best possible energy efficiency ratio (EER).",7.0441670417785645,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]"
