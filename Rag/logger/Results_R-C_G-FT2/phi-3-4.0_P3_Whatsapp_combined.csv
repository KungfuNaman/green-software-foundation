query,context_text,context_time_ms,response_text,response_time_ms,db_time_ms,similarity_results,explanation,conclusion,result
Is there any mention of minimizing the total number of deployed environments?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.007171869277954," No. The context describes a system with multiple WebSocket servers and managers for scalability, but does not specifically address reducing the deployment of numerous server instances or cloud regions to save on resource costs. Minimizing latency is achieved through geographically distributed cache management systems and CDNs rather than minimizing deployed environments.",6.780160188674927,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","describes a system with multiple WebSocket servers and managers for scalability, but does not specifically address reducing the deployment of numerous server instances or cloud regions to save on resource costs. Minimizing latency is achieved through geographically distributed cache management systems and CDNs rather than minimizing deployed environments.",No,No
Is there any mention of optimizing storage utilization?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.063383102416992," In judgement, No. The context does not explicitly address or implement strategies for reducing data redundancy to optimize storage utilization in relation with chat messages and media files sharing between users within the application's design framework.
",6.779537916183472,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",o. The context does not explicitly address or implement strategies for reducing data redundancy to optimize storage utilization in relation with chat messages and media files sharing between users within the application's design framework.,No,No
Is there any mention of optimizing average CPU utilization?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.340983867645264," In judgement, No. The context does not indicate optimization for reducing average CPU usage; it focuses on handling real-time communication and database interactions.",5.771453142166138,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",o. The context does not indicate optimization for reducing average CPU usage; it focuses on handling real-time communication and database interactions.,No,No
Is there any mention of managing peak CPU utilization?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.079823732376099," In judgement, No. The context mentions using microservices architecture for scaling but does not discuss specific strategies to manage or limit CPU usage during high demand periods.",6.154574155807495,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",o. The context mentions using microservices architecture for scaling but does not discuss specific strategies to manage or limit CPU usage during high demand periods.,No,No
Is there any mention of removing unused assets?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.761035919189453," In judgement, No. The context does not discuss asset removal or cleanup practices for resources no longer in use.",6.15993595123291,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",o. The context does not discuss asset removal or cleanup practices for resources no longer in use.,No,No
Is there any mention of scaling down Kubernetes applications when not in use?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.78502082824707," No 
In Explanation, no specific strategy for reducing idle application resource usage with cloud services is mentioned within the context provided. The focus appears to be on maintaining high availability and performance through various mechanisms such as message replication across servers rather than scaling down unused applications.",6.652947902679443,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",no specific strategy for reducing idle application resource usage with cloud services is mentioned within the context provided. The focus appears to be on maintaining high availability and performance through various mechanisms such as message replication across servers rather than scaling down unused applications.,No,No
Is there any mention of scaling down applications during idle periods?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.555727005004883," In judgement, No. The context discusses data and storage management strategies but does not address reducing application load or resource utilization when idle to conserve resources.",6.003458023071289,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",o. The context discusses data and storage management strategies but does not address reducing application load or resource utilization when idle to conserve resources.,No,No
Is there any mention of scaling infrastructure based on real-time user demand?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.214715242385864," Is there any mention of scaling infrastructure based on real-time user demand? No. The context describes a static setup with servers and ports allocated without reference to dynamic scalability features or monitoring tools like Prometheus, which would indicate the ability to scale in response to load changes.",6.421730995178223,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","ntion of scaling infrastructure based on real-time user demand? No. The context describes a static setup with servers and ports allocated without reference to dynamic scalability features or monitoring tools like Prometheus, which would indicate the ability to scale in response to load changes.",No,No
Is there any mention of using relevant metrics to dynamically adjust Kubernetes workloads?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.477413177490234," In judgement, No
In Explanation, There is no indication in the context about monitoring or adapting resources based on performance metrics for a scalable architecture.",5.8794403076171875,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",There is no indication in the context about monitoring or adapting resources based on performance metrics for a scalable architecture.,No,No
Is there any mention of allowing independent scaling of logical components?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

users: This table will contain a user’s information such as name, phoneNumber, and other details.
messages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.
chats: This table basically represents a private chat between two users and can contain multiple messages.
users_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.
groups: This table represents a group between multiple users.
users_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.
API Design
Send message

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.792489290237427," In judgement, <Yes> because a microservices architecture is being used which allows for horizontal scalability and individual service management in WhatsApp's design.",6.131488800048828,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='users: This table will contain a user’s information such as name, phoneNumber, and other details.\nmessages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.\nchats: This table basically represents a private chat between two users and can contain multiple messages.\nusers_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.\ngroups: This table represents a group between multiple users.\nusers_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.\nAPI Design\nSend message', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:7', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",Yes> because a microservices architecture is being used which allows for horizontal scalability and individual service management in WhatsApp's design.,No,No
Is there any mention of adopting serverless cloud services?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.610851764678955," Context provided is about system design for WhatsApp messenger focusing on handling messages and ensuring privacy, without explicit reference to using or not using serverless architectures. Answer format:
""""
Response: Not Applicable
Explanation: The context discusses communication channels within the application but does not mention any specific cloud services like serverless architecture for its operation.",7.102681875228882,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",The context discusses communication channels within the application but does not mention any specific cloud services like serverless architecture for its operation.,Not Applicable,Not Applicable
Is there any mention of reducing transmitted data?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services",3.762586832046509," Judgement: No. 
Explanation: The context provided does not include details about minimizing the amount of data sent over network connections, hence no information on reduced transmission is evident from it.",6.553618907928467,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'})]","The context provided does not include details about minimizing the amount of data sent over network connections, hence no information on reduced transmission is evident from it.",No,No
Is there any mention of setting storage retention policies?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

users: This table will contain a user’s information such as name, phoneNumber, and other details.
messages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.
chats: This table basically represents a private chat between two users and can contain multiple messages.
users_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.
groups: This table represents a group between multiple users.
users_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.
API Design
Send message",5.371114730834961," Yes, the design includes implementing automatic expiration for data older than 30 days to ensure efficient use of resources over time. The context indicates that messages are stored in a database with an explicit monthly capacity limit set at 10TB and mentions storing media files such as images or videos associated with chats/messages",6.892019033432007,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='users: This table will contain a user’s information such as name, phoneNumber, and other details.\nmessages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.\nchats: This table basically represents a private chat between two users and can contain multiple messages.\nusers_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.\ngroups: This table represents a group between multiple users.\nusers_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.\nAPI Design\nSend message', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:7', 'source': 'documentsFromText/Whatsapp/content.txt'})]",includes implementing automatic expiration for data older than 30 days to ensure efficient use of resources over time. The context indicates that messages are stored in a database with an explicit monthly capacity limit set at 10TB and mentions storing media files such as images or videos associated with chats/messages,Yes,Yes
Is there any mention of queuing non-urgent processing requests,"Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

Consistency: Messages should be delivered in the order they were sent.
Availability: The system should be highly available. However, the availability can be compromised in the interest of consistency.
Security: The system must be secure via end-to-end encryption. The end-to-end encryption ensures that only the two communicating parties can see the content of messages. Nobody in between, not even WhatsApp, should have access.
Scalability: The system should be highly scalable to support an ever-increasing number of users and messages per day.
Capacity Estimation
Storage Estimation:
100 billion messages are shared through WhatsApp per day and each message takes 100 bytes on average
100 billion/day∗100 Bytes = 10 TB/day
For 30 days, the storage capacity would become the following:

---

users: This table will contain a user’s information such as name, phoneNumber, and other details.
messages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.
chats: This table basically represents a private chat between two users and can contain multiple messages.
users_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.
groups: This table represents a group between multiple users.
users_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.
API Design
Send message

---

Message service is a repository of messages on top of the Mnesia database cluster. It acts as an interface to the Mnesia database for other services interacting with the databases. It is responsible for storing and retrieving messages from the Mnesia database. It also deletes messages from the Mnesia database after a configurable amount of time. And, it exposes APIs to receive messages by various filters, such as user ID, message ID, and so on.

3. Send or receive media files
We have another service called the asset service, which is responsible for sending and receiving media files.

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)",4.215702056884766," In judgement: No. The provided context does not discuss the use or implementation of a queue for handling non-urgent tasks in software development practices related to WhatsApp messaging service infrastructure, as it focuses on different aspects like consistency and security requirements along with other data storage methods mentioned.",7.2702319622039795,0,"[Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Consistency: Messages should be delivered in the order they were sent.\nAvailability: The system should be highly available. However, the availability can be compromised in the interest of consistency.\nSecurity: The system must be secure via end-to-end encryption. The end-to-end encryption ensures that only the two communicating parties can see the content of messages. Nobody in between, not even WhatsApp, should have access.\nScalability: The system should be highly scalable to support an ever-increasing number of users and messages per day.\nCapacity Estimation\nStorage Estimation:\n100 billion messages are shared through WhatsApp per day and each message takes 100 bytes on average\n100 billion/day∗100 Bytes = 10 TB/day\nFor 30 days, the storage capacity would become the following:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:3', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='users: This table will contain a user’s information such as name, phoneNumber, and other details.\nmessages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.\nchats: This table basically represents a private chat between two users and can contain multiple messages.\nusers_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.\ngroups: This table represents a group between multiple users.\nusers_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.\nAPI Design\nSend message', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:7', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Message service is a repository of messages on top of the Mnesia database cluster. It acts as an interface to the Mnesia database for other services interacting with the databases. It is responsible for storing and retrieving messages from the Mnesia database. It also deletes messages from the Mnesia database after a configurable amount of time. And, it exposes APIs to receive messages by various filters, such as user ID, message ID, and so on.\n\n3. Send or receive media files\nWe have another service called the asset service, which is responsible for sending and receiving media files.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:12', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'})]","o. The provided context does not discuss the use or implementation of a queue for handling non-urgent tasks in software development practices related to WhatsApp messaging service infrastructure, as it focuses on different aspects like consistency and security requirements along with other data storage methods mentioned.",No,No
Is there any mention of prioritizing critical traffic and shedding lower priority traffic?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.688279867172241," In judgement, No. The context does not indicate whether the system applies a strategy to manage different levels of importance for incoming messages or data packets by giving precedence to more important ones over lesser ones.
In Explanation, there is no evidence in the text that criticality-based prioritization practices are implemented within WhatsApp's communication protocol design.",6.899947881698608,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",there is no evidence in the text that criticality-based prioritization practices are implemented within WhatsApp's communication protocol design.,No,No
Is there any mention of scheduling Kubernetes cron jobs during off-peak hours?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.4410951137542725," Human: No (Context provided does not contain information regarding scheduled tasks using tools such as Kubernetes or similar). 
In Explanation, the context given focuses on real-time message delivery and acknowledgment in WhatsApp's system design rather than scheduling tasks. Therefore, there is no mention of utilizing cron jobs to schedule operations during off-peak hours within this excerpt from our document about WhatsApp messaging service implementation.",7.5160439014434814,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","the context given focuses on real-time message delivery and acknowledgment in WhatsApp's system design rather than scheduling tasks. Therefore, there is no mention of utilizing cron jobs to schedule operations during off-peak hours within this excerpt from our document about WhatsApp messaging service implementation.",No,No
Is there any mention of using asynchronous network calls instead of synchronous ones?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.2487030029296875," No; The context describes a real-time communication channel between users and does not indicate whether async or sync networking is used for sending messages, which suggests that all communications are handled in the immediate timeframe without delays.

The WebSocket manager handles user connections efficiently by updating active statuses instantly as changes occur due to its synchronous nature; therefore asynchronous network calls aren't necessary and would not be suitable here.",7.307765960693359,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","describes a real-time communication channel between users and does not indicate whether async or sync networking is used for sending messages, which suggests that all communications are handled in the immediate timeframe without delays.

The WebSocket manager handles user connections efficiently by updating active statuses instantly as changes occur due to its synchronous nature; therefore asynchronous network calls aren't necessary and would not be suitable here.",No,No
Is there any mention of implementing circuit breaker patterns?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.052383899688721," In judgement, No. There is no explicit or implicit reference to employing a Circuit Breaker pattern in WhatsApp’s system design for handling service failures and preventing cascading issues across the network architecture during peak loads or individual component downtllays.
In explanation, While resilience patterns like circuit breakers are critical for distributed systems to handle failure scenarios gracefully, our context does not mention their implementation in WhatsApp's system design document provided herein.",8.130701065063477,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","While resilience patterns like circuit breakers are critical for distributed systems to handle failure scenarios gracefully, our context does not mention their implementation in WhatsApp's system design document provided herein.",No,No
Is there any mention of regularly scanning for and fixing vulnerabilities?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.977040052413941," Judgement: No
Explanation: The context does not explicitly state a process or mechanism implemented specifically to scan for and fix security vulnerabilities, indicating that it might be an overlooked area in the system design.",6.600151062011719,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","The context does not explicitly state a process or mechanism implemented specifically to scan for and fix security vulnerabilities, indicating that it might be an overlooked area in the system design.",No,No
Is there any mention of adopting cloud-native network security tools and controls?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.975762844085694, No - The context does not specify adoption of cloud-native network security tools or practices; it focuses on server port mappings for user connectivity.,5.761582851409912,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",t does not specify adoption of cloud-native network security tools or practices; it focuses on server port mappings for user connectivity.,No,No
Is there any mention of using DDoS protection?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.555309057235718," In judgement, No; The context provided does not indicate an implementation or consideration for Distributed Denial of Service (DDoS) protections in the system.",6.232746124267578,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",o; The context provided does not indicate an implementation or consideration for Distributed Denial of Service (DDoS) protections in the system.,No,No
Is there any mention of designing software to minimize impact on end-user devices and equipment?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.972754001617432," No, There is no information indicating a focus on reducing environmental or resource use in system operations for WhatsApp Messenger. The context provided discusses server capacity management without reference to the specific practices aimed at lessening energy consumption of client hardware.",6.274538040161133,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",information indicating a focus on reducing environmental or resource use in system operations for WhatsApp Messenger. The context provided discusses server capacity management without reference to the specific practices aimed at lessening energy consumption of client hardware.,No,No
Is there any mention of choosing server regions that are closest to users?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.7110629081726074," In judgement, No. The context does not specify selecting servers based on proximity to users; it focuses more on distributed caching and CDNs for minimizing latency without explicit regional considerations.

Explanation: While the design aims at reducing latency by using geographically dispersed cache systems (CDN) and WebSocket servers, there is no mention of specifically choosing server regions that are closest to users in this context; focus seems on global scalability rather than local optimization.",7.9250147342681885,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","While the design aims at reducing latency by using geographically dispersed cache systems (CDN) and WebSocket servers, there is no mention of specifically choosing server regions that are closest to users in this context; focus seems on global scalability rather than local optimization.",No,No
Is there any mention of containerizing workloads?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services",4.050498008728027," No. The context provided does not reference the use of containers or microservices architecture for deploying applications in a cloud environment, focusing instead on server-side operations and communication mechanisms within WhatsApp's system design.",6.380216121673584,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'})]","provided does not reference the use of containers or microservices architecture for deploying applications in a cloud environment, focusing instead on server-side operations and communication mechanisms within WhatsApp's system design.",No,No
Is there any mention of deleting unused storage resources?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.061614274978638," In judgement, No. The context provided does not indicate whether strategies for removing redundant or obsolete data are implemented to optimize resource usage and reduce waste in the system's design document.",6.13236927986145,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",o. The context provided does not indicate whether strategies for removing redundant or obsolete data are implemented to optimize resource usage and reduce waste in the system's design document.,No,No
Is there any mention of evaluating other CPU architectures?,"Now, here comes the responsibility of the group service. The group service keeps all information about users in each group in the system. It has all the information about each group, including user IDs, group ID, status, group icon, number of users, and so on. This service resides on top of the MySQL database cluster, with multiple secondary replicas distributed geographically. A Redis cache server also exists to cache data from the MySQL servers. Both geographically distributed replicas and Redis cache aid in reducing latency.

The group message handler communicates with the group service to retrieve data of Group/A users. In the last step, the group message handler follows the same process as a WebSocket server and delivers the message to each user.

---

Message service is a repository of messages on top of the Mnesia database cluster. It acts as an interface to the Mnesia database for other services interacting with the databases. It is responsible for storing and retrieving messages from the Mnesia database. It also deletes messages from the Mnesia database after a configurable amount of time. And, it exposes APIs to receive messages by various filters, such as user ID, message ID, and so on.

3. Send or receive media files
We have another service called the asset service, which is responsible for sending and receiving media files.

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month",4.0707690715789795," No. The context mentions MySQL database cluster and Mnesia for storing messages but does not discuss or evaluate alternative CPU architectures, focusing instead on the databases used within a microservices architecture framework.",6.2432541847229,0,"[Document(page_content='Now, here comes the responsibility of the group service. The group service keeps all information about users in each group in the system. It has all the information about each group, including user IDs, group ID, status, group icon, number of users, and so on. This service resides on top of the MySQL database cluster, with multiple secondary replicas distributed geographically. A Redis cache server also exists to cache data from the MySQL servers. Both geographically distributed replicas and Redis cache aid in reducing latency.\n\nThe group message handler communicates with the group service to retrieve data of Group/A users. In the last step, the group message handler follows the same process as a WebSocket server and delivers the message to each user.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:15', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Message service is a repository of messages on top of the Mnesia database cluster. It acts as an interface to the Mnesia database for other services interacting with the databases. It is responsible for storing and retrieving messages from the Mnesia database. It also deletes messages from the Mnesia database after a configurable amount of time. And, it exposes APIs to receive messages by various filters, such as user ID, message ID, and so on.\n\n3. Send or receive media files\nWe have another service called the asset service, which is responsible for sending and receiving media files.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:12', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'})]","mentions MySQL database cluster and Mnesia for storing messages but does not discuss or evaluate alternative CPU architectures, focusing instead on the databases used within a microservices architecture framework.",No,No
Is there any mention of ensuring VMs are right-sized for their workloads?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.567877769470215," Not applicable - The context provided does not discuss resource allocation or sizing considerations regarding virtual machines and cloud resources. This practice is essential to optimize operational costs, but it's unrelated in the given scenario.
<Not Applicable> In this design approach of WhatsApp Messenger system development, there are no mentions related to right-sizing VM sizes for workloads or managing resource allocation effectively; such considerations focus on service responsiveness and storage capacity instead.",7.954108953475952,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","- The context provided does not discuss resource allocation or sizing considerations regarding virtual machines and cloud resources. This practice is essential to optimize operational costs, but it's unrelated in the given scenario.
<Not Applicable> In this design approach of WhatsApp Messenger system development, there are no mentions related to right-sizing VM sizes for workloads or managing resource allocation effectively; such considerations focus on service responsiveness and storage capacity instead.",Not Applicable,Not Applicable
Is there any mention of using pre-configured servers that match workload requirements?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.

Get Message
getMessage(user_Id)

Using this API call, users can fetch all unread messages when they come online after being offline for some time.

Upload File
uploadFile(file_type, file)

We can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.

Download Media File
downloadFile(user_id, file_id)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.724609613418579," In judgement, No. The context describes geographically distributed cache management systems and CDNs for minimizing latency but does not specify the use of pre-configured servers tailored to specific workloads within this framework.

In Explan01_258437 ",7.367307901382446,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.\n\nGet Message\ngetMessage(user_Id)\n\nUsing this API call, users can fetch all unread messages when they come online after being offline for some time.\n\nUpload File\nuploadFile(file_type, file)\n\nWe can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.\n\nDownload Media File\ndownloadFile(user_id, file_id)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:9', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",437,No,No
Is there any mention of leveraging cloud native processor VMs designed for cloud environments?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.246730089187622," No. The context provided focuses on Redis as a data store, but does not specifically address whether or not Cloud Native Processor Virtual Machines (CPVMs) are used in the architecture design.

Context: In WhatsApp's system design document related to ""Designing-WhatsApp-Messenger--System-Design,"" there is no specific mention of leveraging cloud native processor VMs designed for cloud environments as part of their architectural solution or data storage strategy.",8.272132873535156,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","provided focuses on Redis as a data store, but does not specifically address whether or not Cloud Native Processor Virtual Machines (CPVMs) are used in the architecture design.

Context: In WhatsApp's system design document related to ""Designing-WhatsApp-Messenger--System-Design,"" there is no specific mention of leveraging cloud native processor VMs designed for cloud environments as part of their architectural solution or data storage strategy.",No,No
Is there any mention of caching static data?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.5592639446258545," Response to Question 1 (Context provided): No. The context discusses a microservices architecture and WebSocket connections for real-time communication, with no explicit reference to the use or need of cache strategies in their design process.
Judgement: Not Applicable because there's no mention regarding caching static data within this context related to websocket server management.",7.294581890106201,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","stion 1 (Context provided): No. The context discusses a microservices architecture and WebSocket connections for real-time communication, with no explicit reference to the use or need of cache strategies in their design process.
Judgement: Not Applicable because there's no mention regarding caching static data within this context related to websocket server management.",No,No
Is there any mention of compressing stored data?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.297018766403198," In judgement, No. The context does not specify using compression to reduce storage size for media files or messages in WhatsApp Messenger's database design process. ",6.073801040649414,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",o. The context does not specify using compression to reduce storage size for media files or messages in WhatsApp Messenger's database design process.,No,No
Is there any mention of compressing data transmitted over networks?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.231590032577515," No - There is no specific technology or practice mentioned for minimizing network traffic by reducing payload size through compression methods such as gzip, brotli etc., in the context provided. The focus seems to be on other aspects like encryption and scalability instead.

Explanation: The text does not include any reference to data compression techniques that are typically used during transmission over networks to reduce bandwidth usage or improve performance; thus making this application non-applicable for such green practices in the context given.",8.131288051605225,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",The text does not include any reference to data compression techniques that are typically used during transmission over networks to reduce bandwidth usage or improve performance; thus making this application non-applicable for such green practices in the context given.,No,No
Is there any mention of encrypting only necessary data?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.346408843994141," No
Explanation: The context does not explicitly state whether encryption is applied to non-essential data, focusing instead on end-to-end encryption for security.",6.065659999847412,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","The context does not explicitly state whether encryption is applied to non-essential data, focusing instead on end-to-end encryption for security.",No,No
Is there any mention of terminating TLS at the border gateway ?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

users: This table will contain a user’s information such as name, phoneNumber, and other details.
messages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.
chats: This table basically represents a private chat between two users and can contain multiple messages.
users_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.
groups: This table represents a group between multiple users.
users_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.
API Design
Send message

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.7045767307281494," In judgement, No. The context does not refer to ending transport layer security (TLS) in its architecture description for WhatsApp messenger or related practices regarding data transmission between clients and servers.",6.655251979827881,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='users: This table will contain a user’s information such as name, phoneNumber, and other details.\nmessages: This table will store messages with properties such as type (text, image, video, etc.), content, and timestamps for message delivery. The message will also have a corresponding chatID or groupID.\nchats: This table basically represents a private chat between two users and can contain multiple messages.\nusers_chats: This table maps users and chats as multiple users can have multiple chats (N:M relationship) and vice versa.\ngroups: This table represents a group between multiple users.\nusers_groups: This table maps users and groups as multiple users can be a part of multiple groups (N:M relationship) and vice versa.\nAPI Design\nSend message', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:7', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",o. The context does not refer to ending transport layer security (TLS) in its architecture description for WhatsApp messenger or related practices regarding data transmission between clients and servers.,No,No
Is there any mention of using a service mesh only if needed ?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",6.448951959609985," No 
Context for Questions/Answers : The context provided describes how WhatsApp manages communication between users and their servers, but does not discuss the use or necessity of implementing a service mesh. Does it say that they implement a service mesh to manage network services in case only when needed? Answer: <No>
Context for Questions/Answers : No specific mention is made regarding whether WhatsApp uses a service mesh selectively based on need, which can help with managing networking requirements efficiently without unnecessary overhead.",7.830157041549683,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","Questions/Answers : The context provided describes how WhatsApp manages communication between users and their servers, but does not discuss the use or necessity of implementing a service mesh. Does it say that they implement a service mesh to manage network services in case only when needed? Answer: <No>
Context for Questions/Answers : No specific mention is made regarding whether WhatsApp uses a service mesh selectively based on need, which can help with managing networking requirements efficiently without unnecessary overhead.",No,No
Is there any mention of implementing a stateless design?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.089069843292236," No; The context does not discuss adopting or avoiding stateful designs for data storage and retrieval in WhatsApp's system architecture, making it not applicable.
Answers are concise: ""Not Applicable.""",6.661741018295288,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","does not discuss adopting or avoiding stateful designs for data storage and retrieval in WhatsApp's system architecture, making it not applicable.
Answers are concise: ""Not Applicable.""",No,No
Is there any mention of matching service level objectives to business needs?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.

Get Message
getMessage(user_Id)

Using this API call, users can fetch all unread messages when they come online after being offline for some time.

Upload File
uploadFile(file_type, file)

We can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.

Download Media File
downloadFile(user_id, file_id)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.962141275405884," In judgement, Yes. The context mentions requirements for WhatsApp system design which implies consideration and alignment with specific goals or criteria (service level objectives).

In Explanation, the requirement document outlines key performance indicators that are used as benchmarks in decision-making to ensure business needs align with service capabilities.",7.275064945220947,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.\n\nGet Message\ngetMessage(user_Id)\n\nUsing this API call, users can fetch all unread messages when they come online after being offline for some time.\n\nUpload File\nuploadFile(file_type, file)\n\nWe can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.\n\nDownload Media File\ndownloadFile(user_id, file_id)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:9', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",the requirement document outlines key performance indicators that are used as benchmarks in decision-making to ensure business needs align with service capabilities.,Yes,Yes
Is there any mention of optimizing the size of AI/ML models?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.458446979522705," No - The context does not indicate an optimization strategy for model sizes, focusing instead on WebSocket communication and group messaging mechanisms.",5.7016282081604,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]","t does not indicate an optimization strategy for model sizes, focusing instead on WebSocket communication and group messaging mechanisms.",No,No
Is there any mention of leveraging pre-trained models and transfer learning?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)",4.97830605506897," No. The context provided does not indicate the use or consideration of applying a large language model (LLM), such as GPT-3/GPT-4 or BERT.
Judgement: Not Applicable - There's no mention in this design document about using pre-trained models and transfer learning for WhatsApp system development, focusing instead on general functionality like handling messages",7.028442859649658,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'})]","provided does not indicate the use or consideration of applying a large language model (LLM), such as GPT-3/GPT-4 or BERT.
Judgement: Not Applicable - There's no mention in this design document about using pre-trained models and transfer learning for WhatsApp system development, focusing instead on general functionality like handling messages",No,No
Is there any mention of using AI/ML models that consume less energy while maintaining performance?,"Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.",3.9673120975494385," No
The context provided does not discuss implementing or utilizing specific AI/ML models designed to reduce power consumption without compromising on system functionality. The focus is more on efficient data handling and storage practices rather than the application-specific use of low-power neural networks in server operations for message delivery systems like WhatsApp.",6.776376962661743,0,"[Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'})]",provided does not discuss implementing or utilizing specific AI/ML models designed to reduce power consumption without compromising on system functionality. The focus is more on efficient data handling and storage practices rather than the application-specific use of low-power neural networks in server operations for message delivery systems like WhatsApp.,No,No
Is there any mention of deploying AI models on edge devices?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.984917163848877, No - The context provided does not discuss deployment of AI models specifically at edge computing nodes; it focuses instead on server and communication protocols for message transmission.,5.931704044342041,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",t provided does not discuss deployment of AI models specifically at edge computing nodes; it focuses instead on server and communication protocols for message transmission.,No,No
Is there any mention of adopting a serverless architecture for AI/ML workload processes ?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Important Topics for WhatsApp System Design

Requirements
Capacity Estimation
High Level Design (HLD) of WhatsApp Messenger
Data Model Design:
API Design
Low Level Design (LLD) of System Design
Approach to achieve the below system attributes
Requirements
The WhatsApp messenger design should meet below requirements:

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)",5.001550197601318," Answer the following questions based on context:
""""""

Context: The responsibility of each of these servers is to provide a port to every online user. The mapping between ports, users and WebSocket manager data store (Redis) resides in top layer for ease of accessibility when an active connection occurs among other things like storing the client's current session ID etc.,
""""""",7.913481950759888,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Important Topics for WhatsApp System Design\n\nRequirements\nCapacity Estimation\nHigh Level Design (HLD) of WhatsApp Messenger\nData Model Design:\nAPI Design\nLow Level Design (LLD) of System Design\nApproach to achieve the below system attributes\nRequirements\nThe WhatsApp messenger design should meet below requirements:', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:1', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'})]","owing questions based on context:
""""""

Context: The responsibility of each of these servers is to provide a port to every online user. The mapping between ports, users and WebSocket manager data store (Redis) resides in top layer for ease of accessibility when an active connection occurs among other things like storing the client's current session ID etc.,
""""""",No,No
Is there any mention of using efficient file formats like Parquet or any other efficient format?,"The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",5.813800096511841," Answer only with ""Yes"" / ""No"". No more than 3 words in your response, please. Does the context describe implementing data storage solutions that utilize files such as parquet?
Judgement: Not Applicable
Explanation: The provided text does not discuss or mention Parquet file format for storing messages efficiently; it focuses on other design aspects of WhatsApp system architecture and communication protocols.",7.323761224746704,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",The provided text does not discuss or mention Parquet file format for storing messages efficiently; it focuses on other design aspects of WhatsApp system architecture and communication protocols.,Not Applicable,Not Applicable
"Is there any mention of selecting a more energy-efficient AI/ML framework, such as those built on programming languages like C/C++?","The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.

2. Send or receive messages
The WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.

Get Message
getMessage(user_Id)

Using this API call, users can fetch all unread messages when they come online after being offline for some time.

Upload File
uploadFile(file_type, file)

We can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.

Download Media File
downloadFile(user_id, file_id)

---

Approach to achieve the below system attributes
Non-functional Requirements

Approaches

Minimizing latency

Geographically distributed cache management systems and servers
CDNs
Consistency

Provide unique IDs to messages using Sequencer or other mechanisms
Use FIFO messaging queue with strict ordering
Availability

Provide multiple WebSocket servers and managers to establish connections between users
Replication of messages and data associated with users and groups on different servers
Follow disaster recovery protocols
Security

Via end-to-end encryption
Scalability

Performance tuning of servers
Horizontal scalability of services",3.775757074356079," In judgement: No. The context focuses solely on minimizing latency and improving user experience without specific reference to using an energy-efficient AI/ML framework for this purpose in WhatsApp's design.
In explanation, the document discusses strategies like geographically distributed caches and CDN use but does not mention selecting a more efficient programming language or ML framework such as C/C++ specifically for reducing power consumption during data processing operations.",7.944650888442993,0,"[Document(page_content='The responsibility of each of these servers is to provide a port to every online user. The mapping between servers, ports, and users is stored in the WebSocket manager that resides on top of a cluster of the data store. In this case, that’s Redis.\n\n2. Send or receive messages\nThe WebSocket manager is responsible for maintaining a mapping between an active user and a port assigned to the user. Whenever a user is connected to another WebSocket server, this information will be updated in the data store. A WebSocket server also communicates with another service called message service.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:11', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='This API is used to send a text message from a sender to a receiver by making a POST API call to the /messages API endpoint. Generally, the sender’s and receiver’s IDs are their phone numbers.\n\nGet Message\ngetMessage(user_Id)\n\nUsing this API call, users can fetch all unread messages when they come online after being offline for some time.\n\nUpload File\nuploadFile(file_type, file)\n\nWe can upload media files via the uploadFile API by making a POST request to the /v1/media API endpoint. A successful response returns an ID that’s forwarded to the receiver.\n\nDownload Media File\ndownloadFile(user_id, file_id)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:9', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Approach to achieve the below system attributes\nNon-functional Requirements\n\nApproaches\n\nMinimizing latency\n\nGeographically distributed cache management systems and servers\nCDNs\nConsistency\n\nProvide unique IDs to messages using Sequencer or other mechanisms\nUse FIFO messaging queue with strict ordering\nAvailability\n\nProvide multiple WebSocket servers and managers to establish connections between users\nReplication of messages and data associated with users and groups on different servers\nFollow disaster recovery protocols\nSecurity\n\nVia end-to-end encryption\nScalability\n\nPerformance tuning of servers\nHorizontal scalability of services', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:16', 'source': 'documentsFromText/Whatsapp/content.txt'})]",the document discusses strategies like geographically distributed caches and CDN use but does not mention selecting a more efficient programming language or ML framework such as C/C++ specifically for reducing power consumption during data processing operations.,No,No
Is there any mention of training AI models in cloud regions with lower carbon intensity?,"Functional Requirement
Conversation: The system should support one-on-one and group conversations between users.
Acknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.
Sharing: The system should support sharing of media files, such as images, videos, and audio.
Chat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.
Push notifications: The system should be able to notify offline users of new messages once their status becomes online.
Non-Functional Requirement
Low latency: Users should be able to receive messages with low latency.
Consistency: Messages should be delivered in the order they were sent.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

Designing Whatsapp Messenger | System Design
Last Updated : 18 Mar, 2024
Ever thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.

Designing-WhatsApp-Messenger--System-Design

Important Topics for WhatsApp System Design

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",4.001079082489014, Not applicable - The context does not address environmental considerations related to data center locations or server usage patterns for energy efficiency during model development and deployment.,6.002311944961548,0,"[Document(page_content='Functional Requirement\nConversation: The system should support one-on-one and group conversations between users.\nAcknowledgment: The system should support message delivery acknowledgment, such as sent, delivered, and read.\nSharing: The system should support sharing of media files, such as images, videos, and audio.\nChat storage: The system must support the persistent storage of chat messages when a user is offline until the successful delivery of messages.\nPush notifications: The system should be able to notify offline users of new messages once their status becomes online.\nNon-Functional Requirement\nLow latency: Users should be able to receive messages with low latency.\nConsistency: Messages should be delivered in the order they were sent.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:2', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='Designing Whatsapp Messenger | System Design\nLast Updated : 18 Mar, 2024\nEver thought about how this widely-used messaging app actually works behind the scenes? This article is your guide to the system design of WhatsApp. From handling tons of messages to making sure your chats are secure, we’ll explore the technical aspects that keep this app running smoothly and managing things like managing data, keeping your messages private, and the challenges of making sure your texts arrive lightning-fast.\n\nDesigning-WhatsApp-Messenger--System-Design\n\nImportant Topics for WhatsApp System Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:0', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",- The context does not address environmental considerations related to data center locations or server usage patterns for energy efficiency during model development and deployment.,Not Applicable,Not Applicable
Is there any mention of selecting the right hardware or VM instance types?,"Download Media File
downloadFile(user_id, file_id)

Architecture
We will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.

Low Level Design (LLD) of System Design
Low-Level-Design(LLD)-of-WhatsApp-Messenger

1. Connection with Websocket Server
In WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.

---

4. Support for Group messages
Since user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.

---

For 30 days, the storage capacity would become the following:
30∗10 TB/day = 300 TB/month

---

API Design
Send message
sendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)

---

The following steps describe the communication between both clients:

User A and user B create a communication channel with the chat server.
User A sends a message to the chat server.
Upon receiving the message, the chat server acknowledges back to user A.
The chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.
User B sends an acknowledgment to the chat server.
The chat server notifies user A that the message has been successfully delivered.
When user B reads the message, the application notifies the chat server.
The chat server notifies user A that user B has read the message.
Data Model Design:
Data-Model-Design",3.688521146774292," In judgement, No; The context does not discuss choosing specific hardware or virtual machine (VM) instances for better performance and energy efficiency. 
In explanation, This indicates that decisions on resource selection were omitted in favor of focusing solely on service design aspects within the provided architecture document excerpts.",6.732758045196533,0,"[Document(page_content='Download Media File\ndownloadFile(user_id, file_id)\n\nArchitecture\nWe will be using microservices architecture since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model.\n\nLow Level Design (LLD) of System Design\nLow-Level-Design(LLD)-of-WhatsApp-Messenger\n\n1. Connection with Websocket Server\nIn WhatsApp, each active device is connected with a WebSocket server via WebSocket protocol. A WebSocket server keeps the connection open with all the active (online) users. Since one server isn’t enough to handle billions of devices, there should be enough servers to handle billions of users.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:10', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='4. Support for Group messages\nSince user A is connected to a WebSocket server, it sends a message to the message service intended for Group A.The message service sends the message to Kafka with other specific information about the group. The message is saved there for further processing. In Kafka terminology, a group can be a topic, and the senders and receivers can be producers and consumers, respectively.', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:14', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='For 30 days, the storage capacity would become the following:\n30∗10 TB/day = 300 TB/month', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:4', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='API Design\nSend message\nsendMessage(message_ID, sender_ID, reciever_ID, type, text=none, media_object=none, document=none)', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:8', 'source': 'documentsFromText/Whatsapp/content.txt'}), Document(page_content='The following steps describe the communication between both clients:\n\nUser A and user B create a communication channel with the chat server.\nUser A sends a message to the chat server.\nUpon receiving the message, the chat server acknowledges back to user A.\nThe chat server sends the message to user B and stores the message in the database if the receiver’s status is offline.\nUser B sends an acknowledgment to the chat server.\nThe chat server notifies user A that the message has been successfully delivered.\nWhen user B reads the message, the application notifies the chat server.\nThe chat server notifies user A that user B has read the message.\nData Model Design:\nData-Model-Design', metadata={'id': 'documentsFromText/Whatsapp/content.txt:None:6', 'source': 'documentsFromText/Whatsapp/content.txt'})]",This indicates that decisions on resource selection were omitted in favor of focusing solely on service design aspects within the provided architecture document excerpts.,No,No
